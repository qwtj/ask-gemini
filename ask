#!/usr/bin/env zsh

# Function to display help
usage() {
    echo "Usage: $0 <prompt> [-m <model name>] [-g] [--glow] [--markdown] [-f <attached_File>]"
    echo "  <prompt>: The text prompt to send to the Gemini API.  If -g is used, this is the initial prompt."
    echo "  -p <prompt path>     Provide a path to a file prompt."
    echo "  -s: Enable Google Search for the prompt."
    echo "  -v: Enable verbose mode."
    echo "  -h, --help: Display this help message."
    echo "  -m <model name>: Specify the model (e.g., gemini-2.0-flash, gemini-1.5-pro, etc.)"
    echo "  Supported models: gemini-2.0-flash, gemini-2.0-flash-lite, gemini-1.5-flash, gemini-1.5-flash-8b, gemini-1.5-pro"
    echo "  -g: Use glow to display the output."
    echo "  -f <attached_File>:  Path to a file to include in the request."
    echo "  -i: List all models along with their details"
    echo "  --markdown: Use markdown table format for the output."
    exit 1
}

# ---------------------------
# Function: get_models_info
# ---------------------------
get_models_info() {
    local api_key="$GOOGLE_API_KEY"
    curl -s https://generativelanguage.googleapis.com/v1beta/models\?key\=$api_key | jq
}

# ---------------------------
# Function: list_model_names
# ---------------------------
list_model_names() {
    curl -s "https://generativelanguage.googleapis.com/v1beta/models?key=$GOOGLE_API_KEY" | jq -r '.models[].name' | sed 's/models\///g'
}

send_prompt_to_gemini() {
    local PROMPT="$1"
    local use_markdown_table="$2"
    local model="$3"
    local attached_File="$4"
    local search_enabled="$5"

    local api_key="$GOOGLE_API_KEY"
    local api_version

    case "$model" in
        gemini-1.5-*) api_version="v1" ;;
        *) api_version="v1beta" ;;
    esac

    local api_url="https://generativelanguage.googleapis.com/${api_version}/models/${model}:generateContent?key=$api_key"

    local parts_array=()

    # Add prompt
    local encoded_prompt=$(echo -n "$prompt" | base64)
    parts_array+=("{\"inline_data\": {\"mime_type\":\"text/plain\", \"data\":\"$encoded_prompt\"}}")

    # Add PDF file if provided
    if [ -n "$attached_File" ]; then
        if [ ! -f "$attached_File" ]; then
            echo "Error: PDF file not found: $attached_File" >&2
            return 1
        fi
        local pdf_base64=$(base64 -i "$attached_File" | tr -d '\r\n')
        parts_array+=("{\"inline_data\": {\"mime_type\":\"$(file -b --mime-type "$attached_File")\", \"data\":\"$pdf_base64\"}}")
    fi

    local request_body
    # Construct request
    if [ "$search_enabled" = "true" ]; then
        request_body="{\"contents\":[{\"parts\":[${(j:, :)parts_array}]}],\"tools\": [{\"google_search\": {}}]}"
     else
        request_body="{\"contents\":[{\"parts\":[${(j:, :)parts_array}]}]}"
    fi

    echo "$request_body" > ".tmp_file"
    # Send request and base64 encode response
    local response=$(curl -s -X POST "$api_url" \
        -H "Content-Type: application/json" \
        --data-binary "@.tmp_file" | base64)

    #rm .tmp_file

    if ! echo "$response" | base64 --decode | jq . >/dev/null 2>&1; then
        echo "Invalid JSON response:" >&2
        echo "$decoded_response" >&2
        return 1
    fi
    
    if [ "$text_response" = "null" ]; then
      echo "Finish Result: $(echo "$response" | base64 --decode | jq)"
      return 1
    fi

    local text_response=$(echo "$response" | base64 --decode | jq -r '.candidates[0].content.parts[] | .text' 2>/dev/null)
    local safety_ratings=$(echo "$response" | base64 --decode | jq -r '.candidates[0].finishReason' 2>/dev/null)

    echo "$response" | base64 --decode | jq > /tmp/.tmp

    if [ -z "$text_response" ]; then
        echo "No text response received." >&2
        return 1
    fi

    if [ "$use_markdown_table" = "true" ]; then
        echo "| Generated Content |"
        echo "|-------------------|"
        echo "| $text_response |"
        echo
        echo "| Finish Reason |"
        echo "|---------------|"
        echo "| $safety_ratings |"
    else
        echo "$text_response"
    fi
}

parse_arguments() {
    local USE_MARKDOWN="false"
    local USE_GLOW="false"
    local MODEL="gemini-2.0-flash"  # Default model
    local ATTACHED_FILE="" # Initialize attached_File
    local VERBOSE="false"
    local SEARCH="false"
    local PROMPT=""

    while [ "$#" -gt 0 ]; do
        case "$1" in
            -p) shift
                if [ -z "$1" ]; then
                    echo "Error: -p requires a prompt"
                    exit 1
                fi
                PROMPT="$(cat "$1")"
                shift
                ;;
            -h|--help)
                usage
                ;;
            -m)
                shift
                if [ -z "$1" ]; then
                    echo "Error: -m requires a model name" >&2
                    print_usage
                fi
                # Validate the provided model against the list from the API.
                valid_models=$(list_model_names)
                if echo "$valid_models" | grep -Fxq "$1"; then
                    MODEL="$1"
                else
                    echo "Error: Unsupported model '$1'. Valid models are:" >&2
                    echo "$valid_models"
                    exit 1
                fi
                ;;
            *)
                echo "Error: Unsupported model '$1'"
                echo "Supported models: gemini-2.0-flash, gemini-2.0-flash-lite, gemini-1.5-flash, gemini-1.5-flash-8b, gemini-1.5-pro"
                exit 1
                ;;
                esac
                ;;
            --markdown) USE_MARKDOWN="true" ;;
            -g) USE_GLOW="true" ;;
            -f) # Handle the -f option
                shift
                ATTACHED_FILE="$1"
                ;;
            -s)
                SEARCH="true"
                ;;
            -v)
                VERBOSE="true"
                ;;
            -i)
                get_models_info
                exit
                ;;
            *)  PROMPT="$1"
        esac
        if [ $# -ge 1 ]; then
            shift
        fi
    done

    jq --null-input '{
        "use_markdown_table": "'"$USE_MARKDOWN"'", 
        "model": "'"$MODEL"'",
        "glow": "'"$USE_GLOW"'",
        "attached_File": "'"$ATTACHED_FILE"'", 
        "search_enabled": "'"$SEARCH"'", 
        "verbose": "'"$VERBOSE"'", 
        "prompt": "'"$PROMPT"'"
    }' | base64
}

main() {
    # ---------------------------
    # Environment Check
    # ---------------------------
    if [ -z "$GOOGLE_API_KEY" ]; then
        echo "Error: GOOGLE_API_KEY environment variable is not set." >&2
        exit 1
    fi

    # Check that some input is provided
    # If no arguments are provided, check if stdin is not empty or a pipe
    # If stdin is empty and no arguments are provided, show usage
    # and exit with an error
    if [[ $# -eq 0  && ! -s /dev/stdin &&  ! -p /dev/stdin ]]; then
        usage
        exit 1
    fi

    # ---------------------------
    # Configuration & Constants
    # ---------------------------
    local PARAMS=$(parse_arguments $@)
    local USE_MARKDOWN=$(echo "$PARAMS" | base64 --decode | jq -r '.use_markdown_table')
    local USE_GLOW=$(echo "$PARAMS" | base64 --decode | jq -r '.glow')
    local MODEL=$(echo "$PARAMS" | base64 --decode | jq -r '.model')
    local ATTACHED_FILE=$(echo "$PARAMS" | base64 --decode | jq -r '.attached_File')
    local VERBOSE=$(echo "$PARAMS" | base64 --decode | jq -r '.verbose')
    local SEARCH=$(echo "$PARAMS" | base64 --decode | jq -r '.search_enabled')
    local PROMPT=$(echo "$PARAMS" | base64 --decode | jq -r '.prompt')
    if [[ -s /dev/stdin || -p /dev/stdin ]]; then
        if [[ -z "$PROMPT" ]]; then
            PROMPT="$(cat -)"
        else
            PROMPT="$PROMPT\n$(cat -)"
        fi
    fi

    if [ -z "$PROMPT" ]; then
        echo "Error: No prompt provided"
        usage
        exit 1
    fi

    if [ "$use_glow" = "true" ]; then
        if ! send_prompt_to_gemini "$PROMPT" "$USE_MARKDOWN" "$MODEL" "$ATTACHED_FILE" "$SEARCH" | glow; then
            exit 1 # Exit if send_prompt_to_gemini failed
        fi
    else
        if ! send_prompt_to_gemini "$PROMPT" "$USE_MARKDOWN" "$MODEL" "$ATTACHED_FILE" "$SEARCH"; then
            exit 1 # Exit if send_prompt_to_gemini failed
        fi
    fi
}

# ---------------------------
# Entry Point
# ---------------------------
main $@