#!/usr/bin/env zsh

# Function to display help
usage() {
    echo "Usage: $0 <prompt> [-m <model name>] [-g] [--glow] [--markdown] [-f <attached_File>]"
    echo "  <prompt>: The text prompt to send to the Gemini API.  If -g is used, this is the initial prompt."
    echo "  -p <prompt path>     Provide a path to a file prompt."
    echo "  -s: Enable Google Search for the prompt."
    echo "  -v: Enable verbose mode."
    echo "  -h, --help: Display this help message."
    echo "  -m <model name>: Specify the model (e.g., gemini-2.0-flash, gemini-1.5-pro, etc.)"
    echo "  Supported models: gemini-2.0-flash, gemini-2.0-flash-lite, gemini-1.5-flash, gemini-1.5-flash-8b, gemini-1.5-pro"
    echo "  -g: Use glow to display the output."
    echo "  -f <attached_File>:  Path to a file to include in the request."
    echo "  -i: List all models along with their details"
    echo "  --markdown: Use markdown table format for the output."
    exit 1
}

# ---------------------------
# Function: get_models_info
# ---------------------------
get_models_info() {
    local api_key="$GOOGLE_API_KEY"
    curl -s https://generativelanguage.googleapis.com/v1beta/models\?key\=$api_key | jq
}

# ---------------------------
# Function: list_model_names
# ---------------------------
list_model_names() {
    curl -s "https://generativelanguage.googleapis.com/v1beta/models?key=$GOOGLE_API_KEY" | jq -r '.models[].name' | sed 's/models\///g'
}

# ---------------------------
# Function: send_gemini_request
# ---------------------------
send_gemini_request() {
    local MODEL="$1"
    local VERBOSE="$2"
    # Default API version not version 1.5 or below
    local API_VERSION="v1beta" 

    case "$MODEL" in
        gemini-1.5-*) api_version="v1" ;;
        *) ;;
    esac
    local API_URL="https://generativelanguage.googleapis.com/${API_VERSION}/models/${MODEL}:generateContent?key=$GOOGLE_API_KEY"

    [[ "$VERBOSE" = "true" ]] && echo "\nSending Request:\n\n\tAPI URL: $API_URL" >&2
    # Send request and base64 encode response
    local response=$(curl -s -X POST "$API_URL" \
        -H "Content-Type: application/json" \
        --data-binary "@.tmp_file" | base64)
    [[ ! "$VERBOSE" = "true" ]] && rm .tmp_file 
    [[ "$VERBOSE" = "true" ]] && echo "$response" | base64 --decode | jq > /tmp/.tmp
    if ! echo "$response" | base64 --decode | jq . >/dev/null 2>&1; then
        echo "Invalid JSON response:" >&2
        echo "$decoded_response" >&2
        return 1
    fi
    
    if [ "$text_response" = "null" ]; then
      echo "Finish Result: $(echo "$response" | base64 --decode | jq)"
      return 1
    fi

    local text_response=$(echo "$response" | base64 --decode | jq -r '.candidates[0].content.parts[] | .text' 2>/dev/null)
    local safety_ratings=$(echo "$response" | base64 --decode | jq -r '.candidates[0].finishReason' 2>/dev/null)

    [[ "$VERBOSE" = "true" ]] && echo "$response" | base64 --decode | jq > /tmp/.tmp

    if [ -z "$text_response" ]; then
        echo "No text response received." >&2
        return 1
    fi

    if [ "$use_markdown_table" = "true" ]; then
        echo "| Generated Content |"
        echo "|-------------------|"
        echo "| $text_response |"
        echo
        echo "| Finish Reason |"
        echo "|---------------|"
        echo "| $safety_ratings |"
    else
        echo "$text_response" | base64
    fi
}

send_prompt_to_gemini() {
    local ENCODED_PROMPT="$1"
    local SEARCH="$2"
    local MODEL="$3"
    local VERBOSE="$4"

     # Add prompt
    local PARTS_ARRAY=()
    PARTS_ARRAY+=("{\"inline_data\": {\"mime_type\":\"text/plain\", \"data\":\"$ENCODED_PROMPT\"}}")

    [[ "$VERBOSE" = "true" ]] && echo "Adding prompt to request body..." >&2

    local request_body
    # Construct request
    if [ "$SEARCH" = "true" ]; then
        request_body="{\"contents\":[{\"parts\":[${(j:, :)PARTS_ARRAY}]}],\"tools\": [{\"google_search\": {}}]}"
     else
        request_body="{\"contents\":[{\"parts\":[${(j:, :)PARTS_ARRAY}]}]}"
    fi
    echo "$request_body" > ".tmp_file"
    send_gemini_request "$MODEL" "$VERBOSE"
}

send_prompt_with_file_to_gemini() {
    local ENCODED_PROMPT="$1"
    local SEARCH="$2"
    local ATTACHED_FILE_PATH="$3"
    local MIME_TYPE="$(file -b --mime-type "$ATTACHED_FILE_PATH")"
    local MODEL="$4"
    local VERBOSE="$5"

    # Add prompt
    local PARTS_ARRAY=()
    PARTS_ARRAY+=("{\"inline_data\": {\"mime_type\":\"text/plain\", \"data\":\"$ENCODED_PROMPT\"}}")

     # Add PDF file if provided
    if [ -n "$ATTACHED_FILE_PATH" ]; then
        if [ ! -f "$ATTACHED_FILE_PATH" ]; then
            echo "Error: PDF file not found: $ATTACHED_FILE_PATH" >&2
            return 1
        fi
        local FILE_BASE64=$(base64 -i "$ATTACHED_FILE_PATH" | tr -d '\r\n')
        PARTS_ARRAY+=("{\"inline_data\": {\"mime_type\":\"$MIME_TYPE\", \"data\":\"$FILE_BASE64\"}}")
    fi

    local request_body
    # Construct request
    if [ "$SEARCH" = "true" ]; then
        request_body="{\"contents\":[{\"parts\":[${(j:, :)PARTS_ARRAY}]}],\"tools\": [{\"google_search\": {}}]}"
     else
        request_body="{\"contents\":[{\"parts\":[${(j:, :)PARTS_ARRAY}]}]}"
    fi
    echo "$request_body" > ".tmp_file"
    send_gemini_request "$MODEL" "$VERBOSE"
}

# ---------------------------
# Function: parse_arguments
# ---------------------------
parse_arguments() {
    local USE_MARKDOWN="false"
    local USE_GLOW="false"
    local MODEL="gemini-2.0-flash"  # Default model
    local ATTACHED_FILE="" # Initialize attached_File
    local VERBOSE="false"
    local SEARCH="false"
    local PROMPT=""

    while [ "$#" -gt 0 ]; do
        case "$1" in
            -p) shift
                if [ -z "$1" ]; then
                    echo "Error: -p requires a prompt"
                    exit 1
                fi
                PROMPT="$(cat "$1")"
                shift
                ;;
            -h|--help)
                usage
                ;;
            -m)
                shift
                if [ -z "$1" ]; then
                    echo "Error: -m requires a model name" >&2
                    print_usage
                fi
                # Validate the provided model against the list from the API.
                valid_models=$(list_model_names)
                if echo "$valid_models" | grep -Fxq "$1"; then
                    MODEL="$1"
                else
                    echo "Error: Unsupported model '$1'. Valid models are:" >&2
                    echo "$valid_models"
                    exit 1
                fi
                ;;
            --markdown) USE_MARKDOWN="true" ;;
            -g) USE_GLOW="true" ;;
            -f) # Handle the -f option
                shift
                ATTACHED_FILE="$1"
                ;;
            -s)
                SEARCH="true"
                ;;
            -v)
                VERBOSE="true"
                ;;
            -i)
                get_models_info
                exit
                ;;
            *)  PROMPT="$1"
        esac
        if [ $# -ge 1 ]; then
            shift
        fi
    done

    jq --null-input '{
        "use_markdown_table": "'"$USE_MARKDOWN"'", 
        "model": "'"$MODEL"'",
        "glow": "'"$USE_GLOW"'",
        "attached_File": "'"$ATTACHED_FILE"'", 
        "search_enabled": "'"$SEARCH"'", 
        "verbose": "'"$VERBOSE"'", 
        "prompt": "'"$PROMPT"'"
    }' | base64
}

main() {
    # ---------------------------
    # Environment Check
    # ---------------------------
    if [ -z "$GOOGLE_API_KEY" ]; then
        echo "Error: GOOGLE_API_KEY environment variable is not set." >&2
        exit 1
    fi

    # Check that some input is provided
    # If no arguments are provided, check if stdin is not empty or a pipe
    # If stdin is empty and no arguments are provided, show usage
    # and exit with an error
    if [[ $# -eq 0  && ! -s /dev/stdin &&  ! -p /dev/stdin ]]; then
        usage
        exit 1
    fi

    # ---------------------------
    # Configuration & Constants
    # ---------------------------
    local PARAMS=$(parse_arguments $@)
    local USE_MARKDOWN=$(echo "$PARAMS" | base64 --decode | jq -r '.use_markdown_table')
    local USE_GLOW=$(echo "$PARAMS" | base64 --decode | jq -r '.glow')
    local MODEL=$(echo "$PARAMS" | base64 --decode | jq -r '.model')
    local ATTACHED_FILE=$(echo "$PARAMS" | base64 --decode | jq -r '.attached_File')
    local VERBOSE=$(echo "$PARAMS" | base64 --decode | jq -r '.verbose')
    local SEARCH=$(echo "$PARAMS" | base64 --decode | jq -r '.search_enabled')
    local PROMPT=$(echo "$PARAMS" | base64 --decode | jq -r '.prompt')

    [ "$VERBOSE" = "true" ] && echo "\nParsed parameters: $(echo "$PARAMS" | base64 --decode)\n" >&2

    if [[ -s /dev/stdin || -p /dev/stdin ]]; then
        if [[ -z "$PROMPT" ]]; then
            PROMPT="$(cat -)"
        else
            PROMPT="$PROMPT\n$(cat -)"
        fi
    fi

    if [ -z "$PROMPT" ]; then
        echo "Error: No prompt provided"
        usage
        exit 1
    fi

    if [[ -n "$ATTACHED_FILE" ]]; then
        [[ "$VERBOSE" = "true" ]] && echo "Sending prompt with attached file to Gemini API..." >&2
        response="$(send_prompt_with_file_to_gemini "$(echo $PROMPT | base64)" "$SEARCH" "$ATTACHED_FILE" "$MODEL" "$VERBOSE")"
    else
        [ "$VERBOSE" = "true" ] && echo "Sending prompt to Gemini API..." >&2
        response="$(send_prompt_to_gemini "$(echo $PROMPT | base64)" "$SEARCH" "$MODEL" "$VERBOSE")"
    fi

    # If glow is enabled, pipe the output to glow
    if [ "$USE_GLOW" = "true" ]; then
        echo "$response" | base64 --decode | glow
    else
        [ "$VERBOSE" = "true" ] && echo -n "\nMessage:\n\n\t" >&2
        echo "$response" | base64 --decode
    fi
}

# ---------------------------
# Entry Point
# ---------------------------
main $@